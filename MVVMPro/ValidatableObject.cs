using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using MVVMPro.Annotations;

namespace MVVMPro
{
    public class ValidatableObject : ObservableObject, IDataErrorInfo
    {
        private List<RuleBinding> RuleList { get; } = new List<RuleBinding>();
        private Dictionary<string, IList<RuleBinding>> RuleMap { get; } = new Dictionary<string, IList<RuleBinding>>();

        /// <summary>
        ///     Adds a rule to the model that does error checking when the model changes
        /// </summary>
        /// <param name="rule">The rule to add</param>
        /// <param name="errorMessage">The error message to throw when the error occurs</param>
        /// <param name="name">An optional propertyName, if specified only updates to this property will invoke the error checking</param>
        public void AddRule(Func<bool> rule, string errorMessage, string name = null)
        {
            if (string.IsNullOrEmpty(name))
            {
                RuleList.Add(new RuleBinding(rule, errorMessage));
                return;
            }

            if (RuleMap.ContainsKey(name))
                RuleMap[name].Add(new RuleBinding(rule, errorMessage));
            else
                RuleMap.Add(name, new List<RuleBinding>(1) { new RuleBinding(rule, errorMessage) });
        }

        /// <summary>
        ///     A method to invoke <see cref="System.ComponentModel.INotifyPropertyChanged.PropertyChanged"/>
        ///     Utilizes the <see cref="CallerMemberNameAttribute"/> to deduce names automatically where possible
        ///     Shall not throw if PropertyChanged is null
        ///     Shall do error checking on all non-named Rules and only on a matching propertyName if one exists, shall <b>not</b> throw otherwise
        ///  </summary>
        /// <param name="propertyName">The name of the property that invoked the model change update behaviour</param>
        [NotifyPropertyChangedInvocator]
        protected override void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            if (!string.IsNullOrEmpty(propertyName) && RuleMap.ContainsKey(propertyName))
                foreach (var rule in RuleMap[propertyName])
                    rule.IsDirty = true;
            base.OnPropertyChanged(propertyName);
        }

        /// <summary>
        ///     Whether this model contains any errors
        /// </summary>
        public bool HasErrors
        {
            get
            {
                var values = RuleMap.Values.SelectMany(ruleList => ruleList).ToList();
                var oldValues = values.Where(rule => !rule.IsDirty);
                if (oldValues.Any(rule => rule.HasError)) return true;
                var newValues = values.Where(rule => rule.IsDirty).ToList();
                newValues.ForEach(rule => rule.Update());
                return newValues.Any(rule => rule.HasError);
            }
        }

        /// <summary>
        ///     A <see cref="IDataErrorInfo.this[string]"/> implementor that simply calls <see cref="GetError(string)"/>
        /// </summary>
        /// <param name="columnName">The rule name to get</param>
        /// <returns>The error message associated with the rule name</returns>
        public string this[string columnName] => GetError(columnName);

        /// <summary>
        ///     A string containing a list of errors generated by this model's state
        /// </summary>
        public string Error
        {
            get
            {
                var firstList = RuleMap.Values.SelectMany(ruleList => ruleList).Where(rule => rule.HasError).Select(rule => rule.Error).ToList();
                var secondList = RuleList.Where(rule => rule.HasError).Select(rule => rule.Error);
                var firstString = string.Join(Environment.NewLine, firstList);
                var secondString = string.Join(Environment.NewLine, secondList);
                if (string.IsNullOrEmpty(firstString))
                    return string.IsNullOrEmpty(secondString) ? string.Empty : secondString;
                if (string.IsNullOrEmpty(secondString))
                    return firstString;
                return firstString + Environment.NewLine + secondString;
            }
        }

        /// <summary>
        ///     Gets a specific error based on property / error name
        ///     Shall not throw if the propertyName does not exist as a rule
        /// </summary>
        /// <param name="propertyName">The property / error name to get the error message for</param>
        /// <returns>propertyName's isolated error message</returns>
        public string GetError(string propertyName)
        {
            if (!RuleMap.ContainsKey(propertyName)) return string.Empty;

            foreach (var rule in RuleMap[propertyName].Where(rule => rule.IsDirty))
                rule.Update();
            var errors = RuleMap[propertyName].Where(rule => rule.HasError).Select(rule => rule.Error).ToList();
            return errors.Count == 0 ? string.Empty : string.Join(Environment.NewLine, errors);
        }
    }
}
